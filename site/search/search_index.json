{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Work in Progress Overview: SkillBase is a showcase distributed application that allows an organization to develop, certify, and track the skill sets of its members. Organizations like schools, employers, or the military. The primary elements of the application are users, skills, and certifications. Users select skills and then follow a workflow to be granted certification. There is lots of room for integration with third-party applications for identity management, content management, social media, etc. A primary goal of this application is to illustrate the use of the most popular tools in use today. Some of the tools used: Modern Java (version 21+) Microservices (Jakarta EE, DDD) Runtime (Wildfly, Spring Boot) Event-Driven (JMS, Kafka, Cloud Events) Feature Flags (Open Features, Flipt) Security (JWT, OAuth, Keycloak) Database (JPA, Postgres, Liquibase) Storage (MinIO, JuiceFS) Containers (Docker) Infrastructure (Terraform, Kubernetes) Configuration (Microprofile, etcd) Workflow (BPMN, Flowable) Search (Elasticsearch) Caching (Redis, Memcached) Interfaces (REST, GraphQL) Logging (Log4j, Slf4j, fluentd) Testing (JUnit, ArchUnit, Testcontainers) Build (Maven and NPM) Monitoring (Microprofile, Prometheus) Frontend (Typescript, SPA, React, MaterialUI) Documentation (Markdown, OpenAPI, MkDocs) Versioning (Git) Modern Java The Skillbase backend is written using modern Java (version 21+). Microservices Designed as a set of microservices, according to the Jakarta EE 10 specifications. Runtime Runs as a set of Docker containers, one-per-service, combined with Wildfly and Spring Boot. Event-Driven Event-driven design allows for maximum scalability, flexibility, and integration with other products. Code is written to the Jakarta JMS specification using Kafka as the message broker. Feature Flags Built-in support for feature-flags using OpenFeatures with a Flipt provider. Security Integrated with IAM provider, Keycloak, for JWT, OAuth, and RBAC security. Database Built on industry-standard Postgres relational database, using the Jakarta JPA framework and the Liquibase schema management tool. Future versions may use MongoDB for account profiles. Storage Object storage is provided by the MinIO distributed object system. Containers All services and providers are deployed as Docker containers for local and cloud use. Infrastructure Infrastructure is built using Terraform code and managed using Kubernetes. Configuration Runtime application configuration is built on the Microprofile Config API running with Etcd as the provider. Workflow Workflow process management is handled using BPMN process diagrams and the Flowable engine and API. Future versions may embed the engine with the application to simplify transaction management. Search Keyword search for skills, etc. is handled by the Elasticsearch search engine. Caching Distributed caching is handled using Redis or Memcached, and their Java APIs. Cache contents will be updated by domain events received from Kafka. Interfaces Application access is through REST and GraphQL endpoints. Logging Logging is handled with Log4j and Slf4j. Log streams across services are aggregated using Fluentd. Testing Unit testing is performed using JUnit tests. Architectural testing is performed using ArchUnit. Integration testing is performed using Testcontainers. Build The Skillbase backend is built using Maven and a variety of plugins. The frontend is built using NPM. Monitoring Monitoring is handled by a combination of Microprofile APIs and the open-source Prometheus tool. Frontend The primary frontend framework is React, with the code written in Typescript. I'll be using other frameworks ReactRouter, ReactQuery, ReactAdmin, NextJS, and MaterialUI. Documentation Documentation of the application is built using Markdown documents, automatic API documentation using OpenAPI, and the open-source MkDocs tool. Versioning Source code versioning and control is done with Git. Full documentation can be found in the 'site' directory.","title":"Home"},{"location":"backend/","text":"Overview:","title":"Overview"},{"location":"backend/build/","text":"Build: The Skillbase backend is built using Maven and a variety of plugins for dependency management, packaging, source formatting, etc. The Docker container names are: 'skillbase/catalog:latest' 'skillbase/image:latest' 'skillbase/member:latest' 'skillbase/workflow:latest' Commands: Type 'mvn clean' to clean Type 'mvn verify' to build Type 'mvn test' to test Type 'mvn wildfly:deploy' to deploy Tools: Type 'psql -d skillbase -U postgres -h localhost -p 5432' for the Postgres tool (password is 'postgres') Type 'sudo mvn liquibase:help' for Liquibase tool Type 'sudo mvn docker:help' for Docker tool Type 'sudo mvn wildfly:help' for Wildfly tool Type 'sudo mvn elasticsearch:help' for Elasticsearch tool Type 'sudo mvn openrewrite:help' for OpenRewrite Links: https://maven.apache.org https://code.revelc.net/formatter-maven-plugin https://maven.apache.org/plugins/maven-javadoc-plugin https://maven.apache.org/plugins/maven-resources-plugin/","title":"Build"},{"location":"backend/design/","text":"Design: Domain-Driven Design: I\u2019ve become a big fan of domain-driven design, primarily because it forces the architecture to focus on the business on its terms. I\u2019m particularly interested in the intersection between DDD, microservices, and GraphQL. I\u2019m going to use a GraphQL schema, in a schema-first approach, to represent the domain model and it should serve as a \u201csingle source of truth\u201d from which other artifacts, such as SQL schemas and Java objects, can be created. Some parts of the system will be built with a code-first approach to take advantage of some of the GraphQL tools. See https://dzone.com/refcardz/getting-started-domain-driven Event-Driven Architecture: An event-driven architecture is such a natural way of looking at applications that it\u2019s hard to choose any other architecture. I\u2019ve been doing some form of event-driven development for most of my career, so it\u2019s gratifying to see it being so widely used these days. I\u2019ll be using Kafka for the message broker and Cloud-Events for the event definitions. The initial version will not use event-sourcing, but future versions will use Debezium for eventual consistency among the various distributed components (microservices, distributed caches, etc). See https://apache.kafka.org See https://docs.confluent.io/kafka-clients/java/current/overview.html See https://cloudevents.io See https://github.com/enriquemolinari/jqueue See https://github.com/gruelbox/transaction-outbox Microservice Implementation: Past iterations have been implemented using a handful of services combined into one monolithic application, but there are definitely advantages to having a more fine-grained, microservice architecture and most new systems are being built this way. I\u2019ll be using a combination of Jakarta EE and Spring Boot as they are the most popular microservice frameworks for Java. Some of the microservices will delegate a portion of their functionality to backend providers (e.g. KeyCloak for IAM). See https://microprofile.io/ See https://smallrye.io See https://spring.io/projects/spring-boot Language (Java 21): I\u2019ve used Java for every backend implementation of this project so far and will use it for this one as well, especially given the recent evolution of Java, with new features like closures, records, etc. See https://docs.oracle.com/en/java/javase/21/docs/api/index.html Framework (Jakarta EE and Spring Boot): Jakarta EE is the latest incarnation of the J2EE framework. I have extensive experience with J2EE so it will be interesting to see how the framework has advanced. I expect to use Jakarta EE, especially the MicroProfile and its extensions, for the core framework. I'll be using Spring Boot for the runtime container for the microservices. See https://jakarta.ee See https://microprofile.io See https://spring.io/projects/spring-boot Authentication / Authorization (Jakarta EE JWT): The Skillbase backend uses the Jakarta EE JWT framework for runtime authentication and authorization. See https://github.com/smallrye/smallrye-jwt See https://microprofile.io/specifications/microprofile-jwt-auth/ Configuration (Jakarta EE Configuration): The Skillbase backend uses the Jakarta EE Config framework for runtime configuration. See https://github.com/smallrye/smallrye-config See https://microprofile.io/specifications/microprofile-config/ Fault-Tolerance (Jakarta EE Fault-Tolerance): The Skillbase backend uses the Jakarta EE Fault-Tolerance framework to implement fault-tolerance. See https://github.com/smallrye/smallrye-fault-tolerance See https://microprofile.io/specifications/microprofile-fault-tolerance/ Feature Flags (OpenFeatures): The Skillbase backend uses the OpenFeatures framework to manage feature flags. See https://openfeature.dev Health (Jakarta EE Health): Sklllbase uses the Jakarta EE Health framework to runtime health information. See https://github.com/smallrye/smallrye-health See https://microprofile.io/specifications/microprofile-health/ Messaging (Jakarta EE JMS): The Skillbase backend uses the Jakarta EE JMS framework to produce and consume events via a message broker (e.g. Kafka). Search (Elasticsearch) The Skillbase backend uses the Elasticsearch engine for keyword search. The search engine is updated via Change Data Capture (CDC) events (e.g. Debezium). See https://elasticsearch.co Persistence (Jakarta EE Persistence, MinIO Object Store): The Skillbase backend uses the Jakara EE Persistence framework for relational (e.g. PostgreSQL) data storage and a distributed object store (e.g. MinIO) for content storage. Distributed objects are accessed through a POSIX file system layer (e.g. JuiceFS). See https://postgresql.org See https://liquibase.com See https://github.com/mtxr/vscode-sqltools See https://minio.com See https://juicefs.com GraphQL (Jakarta Microprofile GraphQL): The Skillbase backend uses the Jakarta Microprofile GraphQL framework to provide GraphQL endpoints. See https://graphql.org See https://github.com/graphql/graphiql See https://github.com/smallrye/smallrye-graphql See https://smallrye.io/smallrye-graphql/maven-plugin/ REST (Jakarta EE JAX-RS): The Skillbase backend uses the Jakarta EE JAX-RS framework to provide REST endpoints. See https://github.com/smallrye/smallrye-open-api See https://microprofile.io/specifications/microprofile-open-api/ See https://openapis.org See https://swagger.io Telemetry (Jakarta EE Telemetry): The Skillbase backend uses the Jakarta EE Telemetry framework to provide runtime telemetry. See https://github.com/smallrye/smallrye-opentelemetry See https://github.com/smallrye/smallrye-opentracing See https://microprofile.io/specifications/microprofile-telemetry/ See https://opentelemetry.io/ Logging (Log4j, Slf4j): The Skillbase backend uses the Log4j and Slf4j libraries to generate logs. See https://log4j.org See https://slf4j.org Testing (JUnit, ArchUnit, Testcontainers): The Skillbase backend uses the JUnit, ArchUnit, and Testcontainers frameworks for testing. See https://archunit.org See https://junit.org See https://testcontainers.com/ Miscellaneous: Docker (https://www.docker.com) JSON Problem Detail (https://github.com/zalando/problem) JSON Schema (https://json-schema.org/draft-07/schema) OpenRewrite (https://docs.openrewrite.org) SDK Man (https://sdkman.io)","title":"Design"},{"location":"backend/test/","text":"Test: Unit Testing (JUnit): The Skillbase backend uses the JUnit framework for unit testing. See https://junit.org Architectural Testing (ArchUnit): The Skillbase backend uses the ArchUnit framework for architectural testing. See https://archunit.org Integration Testing (Testcontainers): The Skillbase backend uses the Testcontainers framework for integration testing. See https://testcontainers.com/","title":"Test"},{"location":"backend/catalog/","text":"Overview:","title":"Overview"},{"location":"backend/catalog/build/","text":"Build: Commands: Type 'mvn clean' to clean Type 'mvn verify' to build Type 'mvn test' to test Type 'mvn wildfly:deploy' to deploy Tools: Type 'psql -d skillbase -U postgres -h localhost -p 5432' for PostgreSQL tool (password is 'postgres') Type 'sudo mvn liquibase:help' for Liquibase tool Type 'sudo mvn docker:help' for Docker tool Type 'sudo mvn wildfly:help' for Wildfly tool Type 'sudo mvn elasticsearch:help' for Elasticsearch tool Type 'sudo mvn openrewrite:help' for OpenRewrite","title":"Build"},{"location":"backend/catalog/design/","text":"Design: The catalog service is responsible for managing a set of categories, skills, and credentials that can be achieved. Categories (e.g. Safety) are a free-form hierarchy used to organize skills. Skills (e.g. CPR) are defined within a category and have a corresponding deployment entity in the workflow service. Credential (e.g. License) are associated with a Skill and have a corresponding process definition in the workflow service. To achieve a credential, a user follows its workflow process. File storage, for images and other artifacts, is based on a POSIX filesystem provided by the JuiceFS filesystem. The catalog service will use the following directory layout. File names will be based on UUIDs and MIME types will be handled by file extensions. skillbase catalog <file-uuid>.<file-extension> ... Domain Entities: CatalogCategory CatalogCredential CatalogSkill Domain Events: SKILLBASE_CATALOG_CATEGORY_CREATED SKILLBASE_CATALOG_CATEGORY_DELETED SKILLBASE_CATALOG_CATEGORY_UPDATED SKILLBASE_CATALOG_CREDENTIAL_CREATED SKILLBASE_CATALOG_CREDENTIAL_DELETED SKILLBASE_CATALOG_CREDENTIAL_UPDATED SKILLBASE_CATALOG_SKILL_CREATED SKILLBASE_CATALOG_SKILL_DELETED SKILLBASE_CATALOG_SKILL_UPDATED Subscribed Events: TBD See Backend / Design for common design elements.","title":"Design"},{"location":"backend/catalog/endpoints/","text":"Endpoints: REST Endpoints: '/catalog' '/catalog/categories' '/catalog/credentials' '/catalog/skills' GraphQL Endpoints: Open './target/generated/schema.graphql' for GraphQL schema","title":"Endpoints"},{"location":"backend/catalog/test/","text":"Test:","title":"Test"},{"location":"backend/common/build/","text":"mvn clean verify install:install-file -Dfile=target/skillbase-backend-common-0.1.jar -DgroupId=com.headspin.skillbase -DartifcatId=skillbase-backend-common -Dversion=0.1 -Dpackaging=jar -DgeneratePom=true","title":"Build"},{"location":"backend/image/","text":"Overview: curl -sSL https://d.juicefs.com/install | sh - juicefs format sqlite3://myjfs.db myjfs juicefs mount sqlite3://myjfs.db ~/jfs juicefs umount ~/jfs","title":"Overview"},{"location":"backend/image/build/","text":"Build: Commands: Type 'mvn clean' to clean Type 'mvn verify' to build Type 'mvn test' to test Type 'mvn wildfly:deploy' to deploy Tools: Type 'sudo mvn docker:help' for Docker tool Type 'sudo mvn wildfly:help' for Wildfly tool Type 'sudo mvn openrewrite:help' for OpenRewrite","title":"Build"},{"location":"backend/image/design/","text":"Design: The Image service is responsible for managing the image of Skillbase objects. The Image service is based on the MinIO distributed object storage system. See Backend / Design for common design elements.","title":"Design"},{"location":"backend/image/endpoints/","text":"Endpoints: REST Endpoints: '/image' '/image/files' GraphQL Endpoints: Open './target/generated/schema.graphql' for GraphQL schema","title":"Endpoints"},{"location":"backend/image/test/","text":"Test:","title":"Test"},{"location":"backend/member/","text":"Overview: The member service manages member profiles, authentication and authorization. It manages the profile information itself, but delegates the authentication and authorization functionality to a third-party IAM. Member groups, roles, and users are one-to-one associated with their counterparts in the IAM.","title":"Overview"},{"location":"backend/member/build/","text":"Build: Commands: Type 'mvn clean' to clean Type 'mvn verify' to build Type 'mvn test' to test Type 'mvn wildfly:deploy' to deploy Tools: Type 'psql -d skillbase -U postgres -h localhost -p 5432' for PostgreSQL tool (password is 'postgres') Type 'sudo mvn liquibase:help' for Liquibase tool Type 'sudo mvn docker:help' for Docker tool Type 'sudo mvn wildfly:help' for Wildfly tool Type 'sudo mvn elasticsearch:help' for Elasticsearch tool Type 'sudo mvn openrewrite:help' for OpenRewrite","title":"Build"},{"location":"backend/member/design/","text":"Design: The member service is responsible for managing users, groups, and achievements. Users represent member profiles. Users can be members of Groups. Achievements are associated with a user. The member service delegates some of its functionality to a third-party IAM (e.g. Keycloak) for authentication, authorization, and JWT tokens. File storage, for images and BPMN models, is based on a POSIX filesystem provided by the JuiceFS filesystem. The member service will use the following directory layout. File names will be based on UUIDs and MIME types will be handled by file extensions. skillbase member <user-uuid> <file-uuid.<file-extension>> ... ... Domain Entities: MemberAchievement MemberGroup MemberProcess MemberUser Domain Events: SKILLBASE_MEMBER_ACHIEVEMENT_CREATED SKILLBASE_MEMBER_ACHIEVEMENT_DELETED SKILLBASE_MEMBER_ACHIEVEMENT_UPDATED SKILLBASE_MEMBER_GROUP_CREATED SKILLBASE_MEMBER_GROUP_DELETED SKILLBASE_MEMBER_GROUP_UPDATED SKILLBASE_MEMBER_PROCESS_CREATED SKILLBASE_MEMBER_PROCESS_DELETED SKILLBASE_MEMBER_PROCESS_UPDATED SKILLBASE_MEMBER_USER_CREATED SKILLBASE_MEMBER_USER_DELETED SKILLBASE_MEMBER_USER_UPDATED Subscribed Events SKILLBASE_WORKFLOW_INSTANCE_CREATED: In response to a workflow instance created event, the member service creates a corresponding MemberProcess entity. SKILLBASE_WORKFLOW_INSTANCE_DELETED: In response to a workflow instance delete event, the member service deletes its corresponding MemberProcess entity. SKILLBASE_WORKFLOW_INSTANCE_UPDATED: In response to a workflow instance updated event, the member service updates its corresponding MemberProcess entity. SKILLBASE_WORKFLOW_PROCESS_STARTED: TBD SKILLBASE_WORKFLOW_PROCESS_STOPPED: TBD SKILLBASE_WORKFLOW_PROCESS_UPDATED: TBD SKILLBASE_WORKFLOW_PROCESS_PASSED: In response to a process pass event, the member service creates a corresponding MemberAchievement entity. SKILLBASE_WORKFLOW_PROCESS_FAILED: TBD See Backend / Design for common design elements.","title":"Design"},{"location":"backend/member/endpoints/","text":"Endpoints: REST Endpoints: '/member' '/member/achievements' '/member/groups' '/member/users' GraphQL Endpoints: Open './target/generated/schema.graphql' for GraphQL schema","title":"Endpoints"},{"location":"backend/member/test/","text":"Test:","title":"Test"},{"location":"backend/workflow/","text":"T Overview:","title":"Overview"},{"location":"backend/workflow/build/","text":"Build: Commands: Type 'mvn clean' to clean Type 'mvn verify' to build Type 'mvn test' to test Type 'mvn wildfly:deploy' to deploy Tools: Type 'psql -d skillbase -U postgres -h localhost -p 5432' for PostgreSQL tool (password is 'postgres') Type 'sudo mvn liquibase:help' for Liquibase tool Type 'sudo mvn docker:help' for Docker tool Type 'sudo mvn wildfly:help' for Wildfly tool Type 'sudo mvn elasticsearch:help' for Elasticsearch tool Type 'sudo mvn openrewrite:help' for OpenRewrite","title":"Build"},{"location":"backend/workflow/design/","text":"Design: The workflow service is responsible for executing process definitions for user achievement of skill credentials. The most common case is a user selects a skill credential and starts a process instance to achieve it. The workflow process is defined by BPMN and can be an arbitrarily complex combination of user tasks, manual tasks, email message, etc. It results in a pass or fail result. A pass result causes a user achievement to be created. File storage, for images and other artifacts, is based on a POSIX filesystem provided by the JuiceFS filesystem. The workflow service will use the following directory layout. File names will be based on UUIDs and MIME types will be handled by file extensions. skillbase workflow <file-uuid>.<file-extension> ... Domain Entities: WorkflowDefinition WorkflowDeployment WorkflowInstance WorkflowTask Domain Events: SKILLBASE_WORKFLOW_DEFINITION_CREATED SKILLBASE_WORKFLOW_DEFINITION_DELETED SKILLBASE_WORKFLOW_DEFINITION_UPDATED SKILLBASE_WORKFLOW_DEPLOYMENT_CREATED SKILLBASE_WORKFLOW_DEPLOYMENT_DELETED SKILLBASE_WORKFLOW_DEPLOYMENT_UPDATED SKILLBASE_WORKFLOW_INSTANCE_CREATED SKILLBASE_WORKFLOW_INSTANCE_DELETED SKILLBASE_WORKFLOW_INSTANCE_UPDATED SKILLBASE_WORKFLOW_TASK_CREATED SKILLBASE_WORKFLOW_TASK_DELETED SKILLBASE_WORKFLOW_TASK_UPDATED Subscribed Events: SKILLBASE_CATALOG_SKILL_CREATED: In response to a skill created event, the workflow service creates a corresponding workflow deployment entity. SKILLBASE_CATALOG_SKILL_DELETED: In response to a skill deleted event, the workflow service deletes its corresponding workflow deployment entity. SKILLBASE_CATALOG_SKILL_UPDATED: In response to a skill updated event, the workflow service updates its corresponding workflow deployment entity. SKILLBASE_CATALOG_CREDENTIAL_CREATED: In response to a credential created event, the workflow service creates a corresponding workflow definition entity. SKILLBASE_CATALOG_CREDENTIAL_DELETED: In response to a credential deleted event, the workflow service deletes its corresponding workflow definition entity. SKILLBASE_CATALOG_CREDENTIAL_UPDATED: In response to a credential updated event, the workflow service updates its corresponding workflow definition entity. See Backend / Design for common design elements.","title":"Design"},{"location":"backend/workflow/endpoints/","text":"Endpoints: REST Endpoints: '/workflow' '/workflow/definitions' '/workflow/deployments' '/workflow/instances' '/workflow/tasks' GraphQL Endpoints: Open './target/generated/schema.graphql' for GraphQL schema","title":"Endpoints"},{"location":"backend/workflow/test/","text":"Test:","title":"Test"},{"location":"client/","text":"Overview: The client project is a command-line Python tool for managing the Skillbase application. Framework (Framework) The primary frontend framework is Flask. Links: https://flask.org","title":"Overview"},{"location":"client/build/","text":"uv run skillbase_tool.py -c tool.json project proj.json","title":"Build"},{"location":"client/design/","text":"Design:","title":"Design"},{"location":"client/test/","text":"Test:","title":"Test"},{"location":"frontend/","text":"Overview: I\u2019ve done heaps of frontend development work in the past, but I\u2019m more focused on backend development these days, so I\u2019m going to go with some popular choices. Framework (React) The primary frontend framework is React, with the code written in Typescript. I'll be using other frameworks ReactRouter, ReactRelay, ReactAdmin, MaterialUI and NextJS. Interfaces (GraphQL, REST) The backend will support GraphQL and REST so the client will have to follow along. I\u2019ll be using the Relay client library since it\u2019s designed for the React framework. Links: https://www.typescriptlang.org https://react.dev https://reactrouter.com https://relay.dev https://tanstack.com/query/v3 https://marmelab.com/react-admin https://nextjs.org","title":"Overview"},{"location":"frontend/build/","text":"Getting Started with Create React App This project was bootstrapped with Create React App . Available Scripts In the project directory, you can run: npm start Runs the app in the development mode.\\ Open http://localhost:3000 to view it in your browser. The page will reload when you make changes.\\ You may also see any lint errors in the console. npm test Launches the test runner in the interactive watch mode.\\ See the section about running tests for more information. npm run build Builds the app for production to the build folder.\\ It correctly bundles React in production mode and optimizes the build for the best performance. The build is minified and the filenames include the hashes.\\ Your app is ready to be deployed! See the section about deployment for more information. npm run eject Note: this is a one-way operation. Once you eject , you can't go back! If you aren't satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own. You don't have to ever use eject . The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it. Learn More You can learn more in the Create React App documentation . To learn React, check out the React documentation . Code Splitting This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting Analyzing the Bundle Size This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size Making a Progressive Web App This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app Advanced Configuration This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration Deployment This section has moved here: https://facebook.github.io/create-react-app/docs/deployment npm run build fails to minify This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify","title":"Build"},{"location":"frontend/build/#getting-started-with-create-react-app","text":"This project was bootstrapped with Create React App .","title":"Getting Started with Create React App"},{"location":"frontend/build/#available-scripts","text":"In the project directory, you can run:","title":"Available Scripts"},{"location":"frontend/build/#npm-start","text":"Runs the app in the development mode.\\ Open http://localhost:3000 to view it in your browser. The page will reload when you make changes.\\ You may also see any lint errors in the console.","title":"npm start"},{"location":"frontend/build/#npm-test","text":"Launches the test runner in the interactive watch mode.\\ See the section about running tests for more information.","title":"npm test"},{"location":"frontend/build/#npm-run-build","text":"Builds the app for production to the build folder.\\ It correctly bundles React in production mode and optimizes the build for the best performance. The build is minified and the filenames include the hashes.\\ Your app is ready to be deployed! See the section about deployment for more information.","title":"npm run build"},{"location":"frontend/build/#npm-run-eject","text":"Note: this is a one-way operation. Once you eject , you can't go back! If you aren't satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own. You don't have to ever use eject . The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.","title":"npm run eject"},{"location":"frontend/build/#learn-more","text":"You can learn more in the Create React App documentation . To learn React, check out the React documentation .","title":"Learn More"},{"location":"frontend/build/#code-splitting","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/code-splitting","title":"Code Splitting"},{"location":"frontend/build/#analyzing-the-bundle-size","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size","title":"Analyzing the Bundle Size"},{"location":"frontend/build/#making-a-progressive-web-app","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app","title":"Making a Progressive Web App"},{"location":"frontend/build/#advanced-configuration","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/advanced-configuration","title":"Advanced Configuration"},{"location":"frontend/build/#deployment","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/deployment","title":"Deployment"},{"location":"frontend/build/#npm-run-build-fails-to-minify","text":"This section has moved here: https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify","title":"npm run build fails to minify"},{"location":"frontend/design/","text":"Design:","title":"Design"},{"location":"frontend/test/","text":"Test:","title":"Test"},{"location":"system/","text":"Overview: This Skillbase application runs locally or in the cloud as a set of Docker containers. In this version, the containers are deployed to local Docker hosts using Terraform. In future versions, the containers will be deployed to the cloud using Kubernetes.","title":"Overview"},{"location":"system/build/","text":"Build: Commands: Type 'sudo mvn tf:apply' to apply terraform plan Type 'sudo mvn tf:destroy' to destroy terraform plan Tools: Type 'sudo docker ps' to see container status Type 'sudo docker restart to restart a container Type 'psql -d skillbase -U postgres -h localhost -p 5432' for the Postgres admin tool (password is 'postgres') Open 'http://localhost:9013' for the ApiSix admin tool Open 'http://localhost:8080/flowable-admin' for the Flowable admin tool Open 'http://localhost:8081/admin' for the Keycloak admin tool Open 'http://localhost:9080' for the Ngnix admin tool Open 'http://localhost:8087' for the Flipt admin tool Links: See https://github.com/deliveredtechnologies/terraform-maven","title":"Build"},{"location":"system/design/","text":"Design: The Skillbase backend is designed as a set of distributed microservices running in Docker containers. Each component of the backend is packaged into a custom Docker image derived from a standard image. For example, the 'skillbase/postgres' image is derived from the standard 'postgres' image, but adds configuration information, etc. Containers (Docker): Containers are here to stay, and Docker is the gold standard. Having a good pipeline from the build system to a Docker system will help with making the application available in the \u201ccloud\u201d and when used with an orchestration system like Kubernetes, should help enormously with scaling the system up. There aren\u2019t any alternatives that are as popular and flexible as Docker, so this is a keeper. See https://docker.com Infrastructure (Terraform and Kubernetes): Terraform is an awesome \"infrastructure as code\" tool. I'm currently using it during development to populate my Docker instance with my containers. It will be a good segue into Kubernetes in future phases. See https://kubernetes.io See https://terraform.io Database (skillbase/postgres): Database functionality (Postgres) runs in a custom container derived from the 'postges:latest' image. The Skillbase image adds SQL DDL to create the main 'skillbase' database. The individual services create their own schema and tables within the main database. The use of seperate schemas will facilitate moving to a database-per-service model in the future. See https://postgresql.org Storage (skillbase/minio): Object storage functionality (MinIO) runs in a custom container derived from the 'minio/minio:latest' image. The Skillbase image adds custom configuration. See https://min.io Identity (skillbase/keycloak): Identity functionality (Keycloak) runs in a custom container derived from the 'quay.io/keycloak/keycloak:latest' image. The Skillbase image adds custom configuration. Keycloak provides standard IAM features like authentication, OAuth suport, JWT token generation, etc. Administration is through a browser interface. Integration with the 'member' service is through a REST API. See https://www.keycloak.org Messaging (skillbase/kafka): Messaging functionality (Kafka) runs in a custom container derived from the 'bitnami/kafka:latest' image. The Skillbase image adds custom configuration and topics. Integration with the individual services is through the Kafka JMS provider. See https://kafka.apache.org Runtime (skillbase/wildfly): Runtime functionality (Wildfly) runs in a custom container derived from the 'quay.io/wildfly/wildfly:latest' image. The Skillbase image adds custom configuration for JDBC drivers, etc. In the first phase, the individual services all share a single Wildfly instance. In future phases, each service will have it's own runtime, base on Wildfly or Spring Boot. See https://www.wildfly.org See https://spring.io/projects/spring-boot See https://docs.spring.io/spring-boot/maven-plugin Workflow (skillbase/flowable): Workflow functionality (Flowable) runs in a custom container derived from the 'flowable/flowable-rest:latest' image. The Skillbase image adds configuration for the database connection, etc. Flowable is the workflow engine used by the Workflow service. It executes workflow processes defined by BPMN diagrams. See https://www.flowable.org Features (skillbase/flipt): Feature flag functionality (Flipt) runs in a custom container derived from the 'docker.flipt.io/flipt/flipt:latest' image. The Skillbase image adds custom configuration. Feature flags are defined using the Flipt browser interface and then propagated to the individual services using a REST API. See https://flipt.io Search (skillbase/elastic): Search functionality (Elasticsearch) runs in a custom container derived from the 'bitnami/elasticsearch:latest' image. The Skillbase image adds custom configuration. The Elasticsearch index is updated using the catalog service domain events. See https://elasticsearch.co Caching (skillbase/redis): Caching functionality (Redis) runs in a custom container derived from the 'redis:latest' image. The Skillbase image adds custom configuration. Redis is used primarily for session management. See https://redis.io Caching (skillbase/memcached): Caching functionality (Memcached) runs in a custom container derived from the 'memcached:latest' image. The Skillbase image adds custom configuration. Memcached is used primarily for session management. See https://memcached.org Change-Data (skillbase/debezium): Change-Data Capture functionality (Debezium) runs in a custom container derived from the 'debezium/server:latest' image. The Skillbase image adds configuration for connectors. Integration with Debezium is through its Postgres and Kafka interfaces. See https://debezium.io Configuration (skillbase/etcd): Configuration functionality (Etcd) runs in a custom container derived from the 'bitnami/etcd:latest' image. The Skillbase image adds custom configuration. Etcd propagates configuration information to the individual services. See https://etcd.io Logging (skillbase/fluentd): Logging functionality (Fluentd) runs in a custom container derived from the 'fluent/fluentd:edge-debian' image. The Skillbase image adds custom configuration. Fluentd aggregates log information from the individual services into a single stream. See https://fluentd.org Web Server (skillbase/nginx): Web server functionality (Nginx) runs in a custom container derived from the 'nginx:1.19.0-alpine' image. The Skillbase image adds custom configuration. See https://nginx.org Monitoring (skillbase/prometheus): Monitoring functionality (Prometheus) runs in a custom container derived from the 'bitnami/prometheus:latest' image. The Skillbase image adds custom configuration. See https://prometheus.io","title":"Design"},{"location":"system/test/","text":"Test:","title":"Test"}]}